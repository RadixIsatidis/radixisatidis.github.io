<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[砖头的博]]></title>
  <subtitle><![CDATA[某砖唠嗑的地方]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://yanleaon.github.io/"/>
  <updated>2014-08-03T09:50:01.304Z</updated>
  <id>https://yanleaon.github.io/</id>
  
  <author>
    <name><![CDATA[Yan Lee]]></name>
    <email><![CDATA[yanleaon@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[排序算法二三事]]></title>
    <link href="https://yanleaon.github.io/2014/08/02/sorts/"/>
    <id>https://yanleaon.github.io/2014/08/02/sorts/</id>
    <published>2014-08-02T04:29:27.000Z</published>
    <updated>2014-08-02T08:55:02.000Z</updated>
    <content type="html"><![CDATA[<p>今天来说说关于排序算法的事情。<br>在正式开始之前唠嗑点别的。这篇文章里边用到的素材，起因是打算写一个可以调用各种算法的dll。当写完算法之后好奇，就干脆写了测试用例来验证各算法运行效率，于是就有了以下内容。<br><a id="more"></a><br>基本上所有数据结构的课程都有关于排序算法的内容。事实上，这么多年来排序算法也算是发展到了一定程度，任何算法只要网上一搜都能有超巨量的信息，wiki上还有现成的、各语言实现的算法，效率都不错。不过这篇文章在于列数据对比以下各算法的运行时间，我所用的代码在文后的链接可以找到。<br>首先简单介绍用到的几个算法，附带wiki链接：<br><a href="http://en.wikipedia.org/wiki/Bubble_sort" target="_blank" rel="external">冒泡排序(bubble sort)</a><br><a href="http://en.wikipedia.org/wiki/Heapsort" target="_blank" rel="external">堆排序(heap sort)</a><br><a href="http://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="external">插入排序(insertion sort)</a><br><a href="http://en.wikipedia.org/wiki/Introsort" target="_blank" rel="external">内省排序(intro sort)</a><br><a href="http://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="external">归并排序(merge sort)</a><br><a href="http://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="external">快速排序(quick sort)</a><br><a href="http://en.wikipedia.org/wiki/Selection_sort" target="_blank" rel="external">选择排序(selection sort)</a><br><a href="http://en.wikipedia.org/wiki/Shellsort" target="_blank" rel="external">希尔排序(shell sort)</a><br>事先说明一点，程序仅仅做了必要的代码优化，而且都是单线程运行。多线程优化这种类似作弊的方法没有用，不过，不代表像是归并啊，快排啊，内省啊之类的算法，我以后不会写多线程版本。<br>这次比较，会使用长度从10到47000的样本，每个算法运行9005次，并抛弃前5次的统计数据然后算平均值。每次运行都会重新产生一个数组用于排序，尽可能保证能在充分随机的情况下执行。<br><img src="/images/2014-08-02/sorts/figure-1.png" alt="Figure1: 排序时间参考" title="Figure1: 排序时间参考"><br>对表格做部分说明。STL迭代方式，是使用C++的STL库的容器和迭代器等方式来处理数据，间接排序是使用C风格的数组，但是使用一个比较器来作为比较大小的工具。C风格数组顾名思义，是非常传统的做法，直接在C风格数组上做排序操作。<br>为了简化部分数据，时间仅保留小数点后4位。再精确多几位不是不可能，但已经没有讨论的意义了。时间当中的9999.0000则是在设置的超时时间内无法完成一次排序。超时时间具体多少我得翻代码，不过记得是非常长……于是就代表这种算法在如此数据量下已经无法愉快的排序了。<br>来一张震撼一点的：<br><img src="/images/2014-08-02/sorts/figure-2.png" alt="Figure2: 排序时间图表" title="Figure2: 排序时间图表"><br>这张表纵轴是时间，横轴是数据量。从表中可以很清晰的看到排序时间恶化情况。三种基本的排序方式，选择、冒泡、插入排序，在数据量8000以后就非常艰难了（冒泡和选择无法完成排序），插入也在12000之后歇菜。堆排序和希尔排序曲线上升比较平滑，不过照这个趋势下去，跪掉也是迟早的事情。归并和快排应当是处于同一个级别的，曲线上升情况类似，不过总的来说快排数据好看一点。这两种算法都可以在多线程模式下工作，如果应用多线程技术，数据应当会好看一些，特别是数据量继续增大的情况下。<br>最后说收内省排序。与其他排序不同，这种排序是一种复合型排序。其原型是快排，但是做了两点改进：   </p>
<ol>
<li>在快排切分区块到一定阈值情况下，更换排序方式。   </li>
<li>取枢纽元素时，改用三分取中的方式，区间首尾中间取三个数，选择值为中间数的那个作为枢纽。   </li>
</ol>
<p>改进的原理在于快排在小数组和基本有序情况下无法迅速收敛。事实证明，这些改进让算法快了一个数量级，同时由于基本思想和快排一样，于是可以改成多线程版本。<br>来看看其他算法和内省的差距：<br><img src="/images/2014-08-02/sorts/figure-3.png" alt="Figure3: 其他算法与内省排序时间比较" title="Figure3: 其他算法与内省排序时间比较"><br>计算方法\(p=(T-I)/I\). 其中，<code>T</code>为其他算法时间，<code>I</code>为内省排序时间。<br>在阈值10以下，使用的是插入排序，因此样本长度为10时内省退化为插入排序。与其他算法对比，在样本长度较小时，内省都比其他算法快一个数量级以上。区别在于1400到3000这一段，内省比快排略慢。原因可能在于算法切换和取中数等消耗了原本的时间提升量。但是不管如何，随着样本数量的增加，其他算法的运行时间均在持续恶化，内省排序的优越性迅速体现。<br>最后再来看看，32位程序和64位程序的效率差别：<br><img src="/images/2014-08-02/sorts/figure-4.png" alt="Figure4: 32bit和64bit程序运行时间比较" title="Figure4: 32bit和64bit程序运行时间比较"><br>计算方法：\(p=(T_{64}-T_{32})/T_{32}\)<br>事实证明，64位程序比32位程序快了一个数量级。至此，还有什么理由不切换到64位平台？<br>你们感受一下。   </p>
]]></content>
    <summary type="html"><![CDATA[<p>今天来说说关于排序算法的事情。<br>在正式开始之前唠嗑点别的。这篇文章里边用到的素材，起因是打算写一个可以调用各种算法的dll。当写完算法之后好奇，就干脆写了测试用例来验证各算法运行效率，于是就有了以下内容。<br>]]></summary>
    
      <category term="Algorithm" scheme="https://yanleaon.github.io/tags/Algorithm/"/>
    
      <category term="Sorts" scheme="https://yanleaon.github.io/tags/Sorts/"/>
    
      <category term="Algorithm" scheme="https://yanleaon.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用JavaScript模拟Java的继承]]></title>
    <link href="https://yanleaon.github.io/2014/07/27/fack-extends/"/>
    <id>https://yanleaon.github.io/2014/07/27/fack-extends/</id>
    <published>2014-07-27T11:24:14.000Z</published>
    <updated>2014-07-27T04:20:53.000Z</updated>
    <content type="html"><![CDATA[<p>在正文开始之前，先唠嗑一点别的。<br>JS的原型链继承的思想非常优秀，但易用性终究没有Java/C++来得好，而且事实上大家都更倾向于使用后者。程序员的世界，简单易用第一。<br>事实上，网上有很多种解决方案提供了类似后者的继承，但是都各有缺陷。要么只是简单的扩展，将父类的方法绑定到子类上，比如各种库的<code>extends</code>方法。要么引入整个巨型开发库，更有甚者直接污染JS原生对象。这里点名批评PrototypeJS，虽然我的方法从它那里学来。用这个库，唯一目的就是它的继承帮助函数，然而PrototypeJS本身是个极大的开发库，而且Bug众多，少人维护，污染JS原生对象，还有最重要的$符。<br>另外提一下WinJS，我的另一个灵感来源。在WinJS出来之前我甚至没能想到微软在JS上有如此造诣。WinJS是个非常碉堡的JS开发库，值得一试。但是为了一个继承帮助函数引入一个完整的开发库，这是极不明智的。<br><a id="more"></a></p>
<p>好了，话归正题。工欲善其事，必先利其器，首先列举开发目标：   </p>
<ol>
<li>简单。这个工程的目的，仅仅是为了一个继承帮助函数，我无意于弄出一个功能复杂难用的工具，这违背我的初衷。工具实现可以很复杂，但保证功能简单易用。   </li>
<li>模拟Java的继承机制，包括构造函数、动态绑定、静态绑定和父类引用。   </li>
<li>当对象实例化(<code>new</code>它的时候)构造函数自动调用。且能提供一个方法让子类的构造函数能够手动调用父类的构造函数。   </li>
<li>能够动态绑定方法和属性，这部分方法和属性应当在<code>new</code>一个实例之后才能通过这个实例访问到。   </li>
<li>提供静态绑定，这部分方法和属性应当通过类名访问。实例化一个对象之后，通过实例不可访问这部分方法和属性。   </li>
</ol>
<p>目标很好但是和现实总是有差距的，由于JS本身的限制，很多事情，除了期待ECMAScript6之外是做不到的。比如：   </p>
<ol>
<li>多态，或者说，通用的参数选择方案。这个事恐怕ECMAScript6也够呛，几乎所有弱类型语言都有着毛病。要实现多态，只能由每个方法自己适配参数列表。   </li>
<li>访问控制。这个不用多说。不过访问控制这种事情，其实质就是某种约定，跟语言本身实现无太大关系。   </li>
</ol>
<p>说了这么多，是该上干货了。首先讲讲这里用到的技术和部分构思，大家感受一下。   </p>
<ol>
<li>关于原型链<br>JS的对象都有一个原型，类似于别的语言中的父类。JS中一切皆对象，包括函数，它其实是一个函数对象。一个函数对象的原型，就是一个<code>Function</code>对象实例。这里可能牵扯到非常多的关于JS对象的知识，不一一展开，回头再开一篇文章写这事。<br>原生JS的继承原理，就是通过原型来记录一个父类实例。由于是一个完整实例，因此不仅会记录方法，还会记录属性值。通过原型链属性<code>prototype</code>或者JS的自动机制可以很方便的访问到，不过普遍看法是这种做法效率不佳。   </li>
<li>关于函数的绑定<br>JS的方法执行时候，会自动初始化一个<code>this</code>变量，这个变量即方法执行的上下文，或者说这个方法所属的对象。聪明如你肯定能举一反三知道，普通函数就是属于<code>window</code>的，于是<code>this</code>指向它。关于<code>this</code>在各种情况下究竟指哪里，各位看官可以自己动手写一写自然明白，或者回头等我另开一文说这事。<br>如果要更改一个方法的<code>this</code>指针，需要用到函数对象的<code>call</code>, <code>apply</code>或者<code>bind</code>方法。这就是实现继承的最主要技术。关于这三个方法的使用自行Google。   </li>
<li>关于继承<br>从语言层面来说，继承的思想其实很简单，就是让子类能够访问到父类的属性和方法的副本。注意到这里所说的是副本。实际上我们可以这么理解，一个类实例化之后，单独保存了父类的一个实例（这也是原型链继承的核心要义），通过不同的入口访问到的属性和方法，其作用域范围是不同的。这里所说的入口，在C++或Java那里可以理解成类型层级，比如父类型变量或者子类型变量，在JS这里则是不同层次的<code>__proto__</code>变量。<br>既然如此，实现继承的方法就是让子类保存父类的方法和属性的副本。   </li>
<li>类型信息<br>Java的类有一个<code>Class&lt;?&gt;</code>属性，保存了类的类型信息。摒弃掉各种繁复的方法和属性，其实这个<code>Class</code>就是为了提供关于类的类型链、接口、属性和方法的相关信息。JS完全可以移植这个概念，使得动态绑定以及构造函数继承方面事半功倍。   </li>
<li>闭包<br>闭包的概念或许很少人能理解清楚。这里吐槽一下，一货自称是平安保险前端架构师来面试，要价25-30K，一问闭包是啥，不知。呵呵！<br>参考这个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</div><div class="line">	someEle.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>{</div><div class="line">		<span class="keyword">var</span> k = list[i];</div><div class="line">		...</div><div class="line">	});</div><div class="line">}</div></pre></td></tr></table></figure><br>在这个例子中，事件函数里边的k，永远只能拿到<code>list[10]</code>，因为<code>i</code>是<code>for</code>这个闭包维护的变量，<code>for</code>执行完之后，<code>i</code>的值是10。要让事件函数能够拿到1到9，需要在<code>for</code>里边加入立即执行函数，将<code>i</code>作为参数，利用这个函数维护一个新的变量，让<code>i</code>固化下来。当然，这个例子很傻，更好一点的例子自行Google。   </li>
</ol>
<p><strong>提供继承、构造函数、动态绑定、静态绑定</strong><br>这个方法是从WinJS那里挖来的，帮助函数提供是个参数   </p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 构造一个类</div><div class="line"> * @param _a {*} 父类引用或构造函数</div><div class="line"> * @param [_b] {function|{}} 构造函数或需要运行期绑定的方法</div><div class="line"> * @param [_c] {{}|null} 需要运行期绑定的方法或null</div><div class="line"> * @param [_d] {{}|null} 需要静态绑定的方法或null</div><div class="line"> * @returns {}</div><div class="line"> */</div><div class="line"><span class="built_in">module</span>.create = <span class="function"><span class="keyword">function</span> <span class="params">(_a, _b, _c, _d)</span> </span>{</div><div class="line">	<span class="comment">// …</span></div><div class="line">}</div></pre></td></tr></table></figure><br>至此，参数的形式只允许以下两种情况   </p>
<ol>
<li>Parent, Constructor, [prototype, [_static]]   </li>
<li>Constructor, [prototype, [_static]]   </li>
</ol>
<p>不符合规范的，都会直接导致错误无法执行。事实上，作为弱类型语言，我们通常无法预期用户将会以什么样的形式提供参数。不过对于这事情其实问题不大，参数弄错了程序肯定跑不起来。<br>我们仍然需要做一些参数适配的工作：   </p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bType = <span class="keyword">typeof</span> _b;</div><div class="line"><span class="keyword">if</span> (<span class="string">'object'</span> == bType || <span class="literal">undefined</span> == _b) {</div><div class="line">	<span class="comment">// 当第二个参数是object或未定义时，表明是第二种参数格式</span></div><div class="line">	_d = _c;</div><div class="line">	_c = _b;</div><div class="line">	_b = _a;</div><div class="line">	_a = <span class="built_in">Object</span>;</div><div class="line">}</div><div class="line">_d = _d || {};</div><div class="line">_c = _c || {};</div><div class="line">_b = _b || <span class="keyword">new</span> <span class="built_in">Function</span>();</div></pre></td></tr></table></figure><br>上边的代码，通过检查参数<code>_b</code>来确定如何移动参数位置，以使参数列表尽量符合最长的规则，即把参数填满。注意上边的<code>_a = Object</code>，这一来，当如果没有提供需要继承的类时，其就从<code>Object</code>继承下来。后边几行是对参数为空时做的默认赋值操作。”<code>||</code>”这种方法逼格相当高。之后我会将这几个参数丢到一个闭包(一个立即执行函数)里，通过闭包维护参数的引用，避免JS变量本身带来的一些小问题。   </p>
<p>这样一来，要实现继承只需要做到以下几点：   </p>
<ol>
<li>创建一个新的类，为它绑定静态方法和属性，并记录类的类型信息   </li>
<li>将构造函数绑定到类的实例上   </li>
<li>在new要给类时，将需要动态绑定的方法和属性绑定到类的实力上   </li>
<li>提供一种机制，让类的方法可以方位到父类实例副本。   </li>
</ol>
<p><strong>方法和属性的绑定</strong><br>主要靠以下几个方法，静态和动态绑定都可以使用，依次调用它们可以完成绑定，并在方法调用时，附加一个父类实例引用到参数列表末端，自行感受一下：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 制作父类对象引用</div><div class="line"> * 基本原理是，深度复制一份父类。为了实现深度复制：</div><div class="line"> * 函数会通过new一个Function并绑定到父类引用对象上</div><div class="line"> * 属性会直接附加到上边</div><div class="line"> * @param $parent</div><div class="line"> * @param $this</div><div class="line"> * @returns {Object}</div><div class="line"> * @private</div><div class="line"> */</div><div class="line"><span class="keyword">var</span> _mkParent = <span class="function"><span class="keyword">function</span> <span class="params">($parent, $this)</span> </span>{</div><div class="line">	<span class="keyword">var</span> keys = _keys($parent);</div><div class="line">	<span class="keyword">var</span> parent = {};</div><div class="line">	_forEach(keys, <span class="function"><span class="keyword">function</span> <span class="params">(key)</span> </span>{</div><div class="line">		<span class="keyword">if</span> (isFunction($parent[key])) {</div><div class="line">			parent[key] = (<span class="keyword">new</span> <span class="built_in">Function</span>(getFnBody($parent[key].toString()))).bind($<span class="keyword">this</span>);</div><div class="line">		} <span class="keyword">else</span> {</div><div class="line">			parent[key] = $parent[key];</div><div class="line">		}</div><div class="line">	});</div><div class="line">	<span class="keyword">return</span> parent;</div><div class="line">};</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 将源对象的方法绑定到目标对象</div><div class="line"> * 注意，源对象只是一个资源对象，目标对象必须是一个对象实例</div><div class="line"> * @param source</div><div class="line"> * @param target</div><div class="line"> * @param parent</div><div class="line"> * @private</div><div class="line"> */</div><div class="line"><span class="keyword">var</span> _bindElement = <span class="function"><span class="keyword">function</span> <span class="params">(source, target, parent)</span> </span>{</div><div class="line">	<span class="comment">// 多个闭包调用父级变量，使用一个闭包维护变量，避免多次调用互相干扰</span></div><div class="line">	(<span class="function"><span class="keyword">function</span> <span class="params">(source, target, parent)</span> </span>{</div><div class="line">		<span class="keyword">var</span> keys = _keys(source);</div><div class="line">		<span class="comment">// 遍历源对象的属性和方法</span></div><div class="line">		_forEach(keys, <span class="function"><span class="keyword">function</span> <span class="params">(key)</span> </span>{</div><div class="line">			<span class="keyword">if</span> (isFunction(source[key])) {</div><div class="line">				<span class="comment">// 函数需要做特殊处理才能绑定到目标对象上</span></div><div class="line">				target[key] = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">					<span class="keyword">var</span> _args = slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>);</div><div class="line">					_args.push(parent);</div><div class="line">					<span class="keyword">return</span> source[key].apply(target, _args);</div><div class="line">				};</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				target[key] = source[key];</div><div class="line">			}</div><div class="line">		});</div><div class="line">	})(source, target, parent);</div><div class="line">};</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 向目标对象添加源对象有而目标对象没有的属性</div><div class="line"> * @param source</div><div class="line"> * @param target</div><div class="line"> * @private</div><div class="line"> */</div><div class="line"><span class="keyword">var</span> _addElements = <span class="function"><span class="keyword">function</span> <span class="params">(source, target)</span> </span>{</div><div class="line">	<span class="keyword">var</span> keys = _keys(source);</div><div class="line">	_forEach(keys, <span class="function"><span class="keyword">function</span> <span class="params">(key)</span> </span>{</div><div class="line">		<span class="keyword">if</span> (!target.hasOwnProperty(key)) {</div><div class="line">			target[key] = source[key];</div><div class="line">		}</div><div class="line">	});</div><div class="line">};</div></pre></td></tr></table></figure><br><strong>构造函数</strong><br>实现构造函数需要注意几点：   </p>
<ol>
<li>父类构造函数不能丢。   </li>
<li>必须是在类被<code>new</code>一个实例时自动执行   </li>
</ol>
<p>仔细看这段代码</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _constructor = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">	<span class="keyword">var</span> _args = slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>);</div><div class="line">	<span class="keyword">var</span> $super = parentClass._constructor || <span class="keyword">new</span> <span class="built_in">Function</span>();</div><div class="line">	$super = $super.bind(<span class="keyword">this</span>);</div><div class="line">	_args.push($super);</div><div class="line">	constructor.apply(<span class="keyword">this</span>, _args);</div><div class="line">};</div></pre></td></tr></table></figure><br>通常来说，既然通过闭包维护参数，东西丢进去之后外边就找不到了的。但JS的引用传递很好的解决了这一问题。实际上，在JS中一切皆对象，还是能够自由添加属性的对象。构造子类时，很容易通过父类的<code>Class</code>对象获得父类的构造函数。这个函数最后一行中，<code>constructor</code>执行时绑定的对象指针式<code>this</code>，因为这个函数执行时，函数的<code>this</code>应当指向调用它的类。<br>所幸原生的JS是有构造函数这个说法的。在原生的JS构造函数中执行我们定义的构造函数就能完成实例化时执行这一目标，并且还能做到更多，比如动态绑定。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _Class = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>{</div><div class="line">	_constructor.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">	…</div><div class="line">}</div></pre></td></tr></table></figure><br>事实上执行这个帮助类，最后返回的是这个<code>_Class</code>。<code>_Class</code>是一个<code>Function</code>对象，<code>new</code>这个<code>_Class</code>会执行这个函数，然后获得一个<code>Object</code>。不要理会JS的怪异之处。这个<code>function</code>自然就是原生JS的构造函数。我们还要在里边做一些更神奇的事情，比如动态绑定。   </p>
<p>改进的地方还有很多，有想法的欢迎联系，代码在<a href="https://github.com/yanleaon/fack-extends" target="_blank" rel="external">这里</a>，只有简单的自测，欢迎帮忙找bug。<br>你们自行感受一下。</p>
]]></content>
    <summary type="html"><![CDATA[<p>在正文开始之前，先唠嗑一点别的。<br>JS的原型链继承的思想非常优秀，但易用性终究没有Java/C++来得好，而且事实上大家都更倾向于使用后者。程序员的世界，简单易用第一。<br>事实上，网上有很多种解决方案提供了类似后者的继承，但是都各有缺陷。要么只是简单的扩展，将父类的方法绑定到子类上，比如各种库的<code>extends</code>方法。要么引入整个巨型开发库，更有甚者直接污染JS原生对象。这里点名批评PrototypeJS，虽然我的方法从它那里学来。用这个库，唯一目的就是它的继承帮助函数，然而PrototypeJS本身是个极大的开发库，而且Bug众多，少人维护，污染JS原生对象，还有最重要的$符。<br>另外提一下WinJS，我的另一个灵感来源。在WinJS出来之前我甚至没能想到微软在JS上有如此造诣。WinJS是个非常碉堡的JS开发库，值得一试。但是为了一个继承帮助函数引入一个完整的开发库，这是极不明智的。<br>]]></summary>
    
      <category term="JavaScript" scheme="https://yanleaon.github.io/tags/JavaScript/"/>
    
      <category term="继承" scheme="https://yanleaon.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="JavaScript" scheme="https://yanleaon.github.io/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Boyer-Moore经典单模式匹配算法]]></title>
    <link href="https://yanleaon.github.io/2014/07/21/pattern-match---boyer-moore/"/>
    <id>https://yanleaon.github.io/2014/07/21/pattern-match---boyer-moore/</id>
    <published>2014-07-20T19:29:23.000Z</published>
    <updated>2014-08-02T12:07:16.000Z</updated>
    <content type="html"><![CDATA[<p>去学模式匹配算法源自于想要做一个拦截短信的应用，根据设定的关键词确定是否拦截这条短信。关于这个应用的事情另开文，这里只说关于模式识别的事情。<br>这文章其实老早就写了，当时找了好几种算法，回头把其他的也po上来。BM算法及其改进型（事实上我用的是它的多模式改进型，另外增加了许多方便提取匹配字串的改进）处于模式匹配算法中匹配速度最快的那一序列，当然，以空间换时间，别扯什么空间和时间都最优，人类历史上这种算法没几个。<br>另外说明一点，文章中有部分图和内容来自别人的博，但时间太久，实在找不到出处，见谅。文中截图代码是Java。<br><a id="more"></a><br>下边会定义几个文章当中用到的符号：<br><strong>定义</strong><br><em>str</em>: 待匹配字符串<br><em>pat</em>: 模式字符串<br><em>pat.len</em>: 模式字符串长度<br><em>pat.pos(char)</em>: 返回字符在字符串内的下标，若字符不存在则返回-1<br><em>pat.lasPos(char)</em>: 返回字符与字符串最右端的相对距离，等同于<em><code>pat.len - pat.pos(char) - 1</code></em><br><em>p</em>: 当前匹配的字符的下标，根据作用的字符串不同下标值不一样，这里只是表示某两个对齐了的字符。  </p>
<h3 id="基本原理">基本原理</h3>
<p>每次匹配一个模式字符串长度的块，从模式字符串右端（即字符串尾部）开始向左端（字符串首部）进行匹配，若串匹配不成功则重新对其str和pat。如<em>Figure1</em>。<br><img src="/images/2014-07-20/pattern-match---boyer-moore/figure-1.jpg" alt="Figure1: BM算法的基本原理" title="Figure1: BM算法的基本原理">    </p>
<h4 id="1-_坏字符规则">1. 坏字符规则</h4>
<p>若末尾不匹配，且str[p]在pat中不存在，那么pat可以一下子右移pat.len个单位。如<em>Figure1</em>到<em>Figure2</em>的变化。<br><img src="/images/2014-07-20/pattern-match---boyer-moore/figure-2.jpg" alt="Figure2: 坏字符规则-当末尾不匹配时，右移*pat.len*个单位" title="Figure2: 坏字符规则-当末尾不匹配时，右移*pat.len*个单位">    </p>
<p>若末尾不匹配，但是str[p]在pat中存在（如果有多个，就找最靠右的那个）距离pat右端为len1= ( pat.len - p )，那么右移pat使这两个字符对齐。如<em>Figure2</em>到<em>Figure3</em>的变化。<br><img src="/images/2014-07-20/pattern-match---boyer-moore/figure-3.jpg" alt="Figure3: 坏字符规则-在*pat*中存在多个*str[p]*，找最靠右那个" title="Figure3: 坏字符规则-在*pat*中存在多个*str[p]*，找最靠右那个">    </p>
<p>总结以上两点可以看到，需要跳过的字符数可以用以下公式表示：<br><img src="/images/2014-07-20/pattern-match---boyer-moore/fn-1.jpg" alt="需要跳过的字符数" title="需要跳过的字符数"></p>
<h4 id="2-_好后缀规则">2. 好后缀规则</h4>
<p>末<code>m</code>位都匹配上了<code>(m&lt;pat.len)</code>，但未匹配完，当前字符发生了<strong>mis-match</strong>(匹配失败)，当前字符记为<strong>MMC</strong>(<em>Mis Matched Char</em>，失配字符)。如<em>Figure4</em>，在<code>m=4</code>上发生了<em>mis-match</em>。<br><img src="/images/2014-07-20/pattern-match---boyer-moore/figure-4.jpg" alt="Figure4: 匹配失败" title="Figure4: 匹配失败">    </p>
<p>如<em>Figure4</em>示例1，<code>str</code>中的<code>&#39;c&#39;</code>在<code>pat</code>中的最有出现居然还在小指针靠后的位置，因为不能让<code>pat</code>往左滑，遇到这种情况，让<code>pat</code>往右滑<code>k=1</code>个位置，此时小指针移到<code>pat</code>末端，小指针向右<code>s=k+m=5</code>个位置。<br>如<em>Figure4</em>示例2，<code>str</code>中<code>a</code>在<code>pat</code>中的最右出现在小指针前面，则让这两个<code>a</code>对其，即让<code>pat</code>向右滑<code>k=pat.lasPos(&#39;a&#39;)–m=6–4=2</code>个位置，此时小指针为了滑至<code>pat</code>最后，需要向右移动<code>k+m=(pat.lasPos(&#39;a&#39;)-m)+m=pat.lasPos(&quot;a&quot;)=6</code>个位置。<br>如<em>Figure4</em>示例3，<code>str</code>中<code>y</code>在<code>pat</code>中未出现，那么将<code>pat</code>向右移动<code>k=pat.lasPos(&#39;y&#39;)-m=6-4=2</code>个位置，此时小指针为了滑至<code>pat</code>最后需要移动<code>pat.lasPos(&quot;y&quot;)个位置</code>。   </p>
<p><em>Figure5</em>示例1，末m(m=3)位匹配上了，记为subpat，那么pat中出现的最右的且不由MMC引导的subpat，记为subpat的”重现位置”，例如str=”gabcfabceabceabc”与subpat=”abc”，MMC为字符’e’，那么重现位置为字符’f’引导的subpat，因为字符’g’引导的subpat不是最右的，而倒数第二个’e’引导的subpat，则因为’e’是MMC。<br><img src="/images/2014-07-20/pattern-match---boyer-moore/figure-5.jpg" alt="Figure5: 匹配失败" title="Figure5: 匹配失败">    </p>
<p>引入一个<code>Shift</code>函数如下：   </p>
<pre><code>shift(str[<span class="keyword">j</span>]) = <span class="built_in">max</span>(<span class="keyword">k</span>|
    <span class="keyword">k</span> &lt; pat.<span class="built_in">len</span> &amp;&amp; 
    pat.subStr(<span class="keyword">j</span> + <span class="number">1</span>, pat.<span class="built_in">len</span>) == pat.subStr(<span class="keyword">k</span>, <span class="keyword">k</span> + pat.<span class="built_in">len</span> - <span class="keyword">j</span> - <span class="number">1</span>) &amp;&amp; 
    (<span class="keyword">k</span> &lt;= <span class="number">0</span> || pat[<span class="keyword">k</span>-<span class="number">1</span>] != pat[<span class="keyword">j</span>])
)   
</code></pre><p>那么当发生mis-match时，”重现位置”在<em><code>shift(str[mmc])</code></em>，那么pat需要右移 <em><code>k=mmc-shift(str[mmc])</code></em> ，小指针需要右移 <em><code>k+m=pat.len-shift(str[mmc])</code></em> 。  </p>
<h3 id="具体算法">具体算法</h3>
<h4 id="1-_扫描pat，建立坏字符表">1. 扫描pat，建立坏字符表</h4>
<p>坏字符表示用<code>Map&lt;Character, Integer&gt;</code>存储，每一个可能的字符，均存储其距离模式字符串最右端的距离。若字符不存在则为模式串长度。即表示若发生失配的是此字符，则搜索指针应跳过的字符数。<br>建立过程只需要扫描模式字符串，将每一个出现的字符，用模式串长度减去其下标即可。   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> length = <span class="keyword">this</span>.pat.length();   </div><div class="line"><span class="keyword">int</span> pos = length;</div><div class="line"></div><div class="line"><span class="comment">// 制作坏字符表</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {   </div><div class="line">	<span class="keyword">this</span>.skip.put(<span class="keyword">this</span>.pat.charAt(i), pos);   </div><div class="line">	pos -= <span class="number">1</span>;   </div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="2-_建立好后缀表">2. 建立好后缀表</h4>
<p>好后缀表使用一个与模式字符串等长的数组存储，表示在某位置发生失配应该跳过的字符数。<br>建立好后缀表时，从右往左，不断增大失配时已匹配字符串长度，从而找到离右端最近且最长的重现字符串。   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 制作好后缀表</span></div><div class="line">Integer[] shift = <span class="keyword">new</span> Integer[<span class="keyword">this</span>.pat.length()];</div><div class="line">pos = length - <span class="number">1</span>;	<span class="comment">//发生失配的字符的下标，从最后一个字符开始。</span></div><div class="line"><span class="comment">// 保存模式串中最后一个字符，因为要反复用到它</span></div><div class="line">lastestChar = <span class="keyword">this</span>.pat.charAt(length - <span class="number">1</span>);</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 以最后一个字符为边界时，确定移动1的距离</div><div class="line"> * 即如果后缀只有最后一个字符，移动距离为1</div><div class="line">*/</div><div class="line">shift[pos] = <span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> p1 = -<span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> p2 = -<span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> p3 = -<span class="number">1</span>;</div><div class="line"><span class="keyword">while</span> (pos-- &gt; <span class="number">0</span>) {</div><div class="line">	p1 = length - <span class="number">2</span>;</div><div class="line">	<span class="comment">//该do...while循环完成 以当前 matchEnd 所指的字符为边界时，要移动的距离</span></div><div class="line">	do{</div><div class="line">		<span class="comment">/*</span></div><div class="line">		 * 该空循环，寻找 与最后一个字符(变量lastestChar所指字符)匹配的字符所</div><div class="line">		 * 指向的位置。首先拿 p1 与 lastestChar 比较，然后 p1 向左移一位。</div><div class="line">		 * 注意匹配成功之后，p1还会左移一位。</div><div class="line">		 */</div><div class="line">		<span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.pat.charAt(p1--) != lastestChar);</div><div class="line">		<span class="comment">/*</span></div><div class="line">		 * 令 p2 成为倒数第二个字符</div><div class="line">		 * p2 作用是找到一个字符串[p2, lastestChar]，令其与[p3, p1]相同。</div><div class="line">		 * 由于 p1 在于 lastestChar 进行比较之后自增了1，因而 p2 需要从倒数</div><div class="line">		 * 第二个字符开始，这可以减少一次不必要的匹配（对最后一个字符进行匹配）。</div><div class="line">		 */</div><div class="line">		p2 = length - <span class="number">2</span>;</div><div class="line">		<span class="comment">/*</span></div><div class="line">		 * 令 p3 与 p1 一样，pat.charAt(p3+1) == lastestChar</div><div class="line">		 */</div><div class="line">		p3 = p1;</div><div class="line">		<span class="comment">/*</span></div><div class="line">		 * 该空循环，判断在边界内字符匹配到了什么位置</div><div class="line">		 * 匹配是以 pos 为失配字符下标时，即匹配的字符串最长可能为[pos, lastestChar]，而[p2, lastestChar]为前者的子串。</div><div class="line">		 * 采用逐步曾长[pos, lastestChar]的办法，匹配后缀。</div><div class="line">		 */</div><div class="line">		<span class="keyword">while</span> (p3 &gt;= <span class="number">0</span> </div><div class="line">				&amp;&amp; <span class="keyword">this</span>.pat.charAt(p3--) == <span class="keyword">this</span>.pat.charAt(p2--)</div><div class="line">				&amp;&amp; p2 &gt;= pos);</div><div class="line">		<span class="comment">/*</span></div><div class="line">		 *  如果上一个循环跳出的结果是 p2 &lt; pos，这个while的判断条件肯定是false</div><div class="line">		 *  p2 &lt; pos 这个条件主要保证模式串移动的距离尽可能为最大，由于较小的匹配串在 pos 较大时已经找到，且位置为靠近右端，</div><div class="line">		 *  因而逐步减小 pos 的同时，需要保证p2和p3失配时[p2, lastestChar]不要太小。因而若 p2&gt;=pos 则是之前已经找到了这样的</div><div class="line">		 *  较小的匹配串，需要重新寻找匹配串。</div><div class="line">		 *  p3 &lt; startOfStr 为相似串极为靠近开头，匹配过程中 p3 已经出去了。</div><div class="line">		 */</div><div class="line">	}<span class="keyword">while</span>(p3 &gt;= <span class="number">0</span> &amp;&amp; p2 &gt;= pos);</div><div class="line">	shift[pos] = length - <span class="number">1</span> - p3; </div><div class="line">}</div><div class="line"><span class="keyword">this</span>.shift = shift;</div></pre></td></tr></table></figure>    

<h4 id="3-_进行匹配">3. 进行匹配</h4>
<p>如何进行匹配较为简单，一种较为简单的思路是将pat与str对齐，从pat最末字符串开始进行匹配，若失配，对失配下标依次查询好后缀表和坏字符表，然后选择数值较大者将pat重新与str对齐。重复上述流程直到匹配成功或失败。   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span>(<span class="keyword">final</span> String str){</div><div class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.pat.length() == <span class="number">0</span>){</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span>(<span class="keyword">null</span> == str){</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	}</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> patLen = <span class="keyword">this</span>.pat.length();</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> strLen = str.length();</div><div class="line">	<span class="keyword">this</span>.large = patLen + strLen + <span class="number">1000</span>;</div><div class="line">	<span class="comment">// 用于比较字符在当前在str中的位置</span></div><div class="line">	<span class="keyword">int</span> strIndex = patLen;</div><div class="line">	<span class="comment">// 用于比较的字符当前在pat中的位置</span></div><div class="line">	<span class="keyword">int</span> patIndex = -<span class="number">1</span>;</div><div class="line">	<span class="comment">// 依据坏字符规则需要跳过的字符数</span></div><div class="line">	<span class="keyword">int</span> skipStride = -<span class="number">1</span>;</div><div class="line">	<span class="comment">// 依据好后缀规则需要跳过的字符数</span></div><div class="line">	<span class="keyword">int</span> shiftStride = -<span class="number">1</span>;</div><div class="line">	<span class="comment">// 只要strIndex不超出strLen就继续循环，否则跳出。</span></div><div class="line">	<span class="keyword">while</span>(strIndex &lt;= strLen){</div><div class="line">		<span class="comment">//[1]</span></div><div class="line">		<span class="comment">// 每次循环首先把pat待比较字符初始化为pat长度，比较时需要先自减。</span></div><div class="line">		patIndex = patLen;</div><div class="line">		<span class="comment">// 从pat最末开始逐个倒退进行匹配，如果发生失配则跳出循环</span></div><div class="line">		<span class="keyword">while</span>(str.charAt(--strIndex) == <span class="keyword">this</span>.pat.charAt(--patIndex)){</div><div class="line">			<span class="keyword">if</span>(strIndex &lt; <span class="number">0</span>){	<span class="comment">// 若 strIndex &lt; 0 则证明str长度小于pat，匹配失败。</span></div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			}</div><div class="line">			<span class="keyword">if</span>(patIndex == <span class="number">0</span>){	<span class="comment">// 若 patIndex == 0 则表明匹配成功。</span></div><div class="line">				<span class="keyword">this</span>.matchPos = strIndex;	<span class="comment">// 赋值匹配成功位置，返回true</span></div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="comment">// 发生失配，以此查询好后缀表和坏字符表</span></div><div class="line">		skipStride = <span class="keyword">this</span>.skip(str.charAt(strIndex));</div><div class="line">		shiftStride = <span class="keyword">this</span>.shift(patIndex);</div><div class="line">		<span class="comment">// 选择两者中较大者，赋值strIndex，重新对齐pat和str</span></div><div class="line">		strIndex += Math.max(shiftStride, skipStride);		</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">}</div></pre></td></tr></table></figure> 

<p>一种改进的算法则是考虑到坏字符的可能性更多一些，且计算坏字符跳跃距离更简单，可以将这一部分独立出来。在上文代码中的<em>[1]</em>位置插入如下代码：   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line"><span class="comment">/*</span></div><div class="line"> * 坏字符情况（即最后一个字符不匹配）较为普遍，坏字符情况需要计算量少且跳跃距离大，</div><div class="line"> * 因此独立出来，可以进一步加快匹配速度。</div><div class="line"> */</div><div class="line"><span class="keyword">int</span> i = strIndex;</div><div class="line">do {</div><div class="line">	i -= <span class="number">1</span>;	<span class="comment">// 注意到 i 所指字符对应 pat.lastChar + 1，因此需要自减1</span></div><div class="line">	i += <span class="keyword">this</span>.skipC(str.charAt(i));	<span class="comment">// skip所返回的值，是跳跃到 pat.lastChar + 1 位置所需要移动的数值。</span></div><div class="line">	<span class="keyword">if</span> (i &gt; strLen) {</div><div class="line">		i += <span class="number">1</span>;	<span class="comment">// 当需要跳出时自加1，令其所处位置可对应到 pat.lastChar + 1</span></div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	}</div><div class="line">} <span class="keyword">while</span> (<span class="keyword">true</span>);</div><div class="line"><span class="keyword">if</span> (i &lt;= <span class="keyword">this</span>.large) {</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">}</div><div class="line">i = (i - <span class="keyword">this</span>.large);</div><div class="line">strIndex = i;</div></pre></td></tr></table></figure>     

<p>最后参考资料就不提供了，上Google一大堆。<br>Have a nice day.</p>
]]></content>
    <summary type="html"><![CDATA[<p>去学模式匹配算法源自于想要做一个拦截短信的应用，根据设定的关键词确定是否拦截这条短信。关于这个应用的事情另开文，这里只说关于模式识别的事情。<br>这文章其实老早就写了，当时找了好几种算法，回头把其他的也po上来。BM算法及其改进型（事实上我用的是它的多模式改进型，另外增加了许多方便提取匹配字串的改进）处于模式匹配算法中匹配速度最快的那一序列，当然，以空间换时间，别扯什么空间和时间都最优，人类历史上这种算法没几个。<br>另外说明一点，文章中有部分图和内容来自别人的博，但时间太久，实在找不到出处，见谅。文中截图代码是Java。<br>]]></summary>
    
      <category term="Algorithm" scheme="https://yanleaon.github.io/tags/Algorithm/"/>
    
      <category term="Pattern Match" scheme="https://yanleaon.github.io/tags/Pattern-Match/"/>
    
      <category term="Algorithm" scheme="https://yanleaon.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World!!!]]></title>
    <link href="https://yanleaon.github.io/2014/07/21/hello-world/"/>
    <id>https://yanleaon.github.io/2014/07/21/hello-world/</id>
    <published>2014-07-20T17:55:37.000Z</published>
    <updated>2014-07-27T04:20:54.000Z</updated>
    <content type="html"><![CDATA[<p>根据程序员的传统，第一篇文章必须是”Hello World!!!”, 大小写标点符号全中，一个都不能少。<br>原以为开博这种事会离我很远的，不大喜欢写东西，有时间玩文字游戏还不如多写两行代码。然而最近发觉自己越来越健忘了，不是大脑退化，而是接触的东西越来越多，已经达不到那种需要用时很快想到那种状态了。在别人看来，就是你反应越来越慢，或者说，你这货根本就是不懂装懂。于是。。。好吧，写个博。<br>一是为了把一些需要记录的东西记下来。虽然其实不开博也能做到，但是开了博，自然会有一些别的好处，比如:<br>二是为了秀优越感、找存在感，你看，一大波干货，我懂的你们都不懂balabala。。。<br>三是做个预防，找工作时候好歹加点筹码<br>还有个临时想到的好处，妹子要转行做前端，回头这个博就给她设计吧，纯当练手，反正有我看着出不了啥大问题。<br>第一篇就到这吧。准备好了么，一大波干货来袭。</p>
]]></content>
    
    
      <category term="Blog" scheme="https://yanleaon.github.io/tags/Blog/"/>
    
      <category term="Essay" scheme="https://yanleaon.github.io/tags/Essay/"/>
    
      <category term="Essay" scheme="https://yanleaon.github.io/categories/Essay/"/>
    
  </entry>
  
</feed>
